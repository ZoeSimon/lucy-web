import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import java.util.regex.Pattern

/*
 * takes in a sonarqube status json payload
 * and returns the status string
 */
def sonarGetStatus (jsonPayload) {
  def jsonSlurper = new JsonSlurper()
  return jsonSlurper.parseText(jsonPayload).projectStatus.status
}

pipeline {
    agent none
    options {
        disableResume()
    }
    stages {
        stage('Build') {
            parallel {
                stage('Build API') {
                    agent { label 'build' }
                    steps {
                        sh 'printenv'
                        script {
                            echo "API Build Pipeline"
                            def filesInThisCommitAsString = sh(script:"git diff --name-only HEAD~1..HEAD | grep -E '^api/|^/api/|^app/|^/app/' || echo -n ''", returnStatus: false, returnStdout: true).trim()
                            def hasChangesInPath = (filesInThisCommitAsString.length() > 0)
                            echo "${filesInThisCommitAsString}"
                            if (!currentBuild.rawBuild.getCauses()[0].toString().contains('UserIdCause') && !hasChangesInPath){
                                currentBuild.rawBuild.delete()
                                error("No changes detected in the path ('^api/')")
                            }
                        }
                        echo "Aborting all running jobs ..."
                        script {
                            abortAllPreviousBuildInProgress(currentBuild)
                        }
                        echo "Building ..."
                        sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run build -- --pr=${CHANGE_ID}"
                        /*sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run build-tools --pr=${CHANGE_ID}"*/
                    }

                }
                stage('Build APP') {
                    agent { label 'build' }
                    steps {
                        script {
                            echo "App Build Pipeline"
                            def filesInThisCommitAsString = sh(script:"git diff --name-only HEAD~1..HEAD | grep -E '^/app/|^app/|^api/|^/api/' || echo -n ''", returnStatus: false, returnStdout: true).trim()
                            def hasChangesInPath = (filesInThisCommitAsString.length() > 0)
                            if (!currentBuild.rawBuild.getCauses()[0].toString().contains('UserIdCause') && !hasChangesInPath){
                                currentBuild.rawBuild.delete()
                                error("No changes detected in the path ('^app/')")
                            }
                        }
                        echo "Aborting all running jobs ..."
                        script {
                            abortAllPreviousBuildInProgress(currentBuild)
                        }
                        echo "Building ..."
                        sh "cd app/.pipeline && ./npmw ci && DEBUG=* ./npmw run build -- --pr=${CHANGE_ID}"
                    }
                }
            }
        }
        stage('Pre Deploy (Dev)') {
            agent { label 'deploy' }
            steps {
                echo "Deploying Postgress DB"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run pre-deploy -- --pr=${CHANGE_ID} --env=dev"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run setup -- --pr=${CHANGE_ID} --env=dev"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run seed -- --pr=${CHANGE_ID} --env=dev"
            }
        }
        stage('Test API (Dev)') {
            agent { label 'deploy' }
            steps {
                echo "Testing app"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run test -- --pr=${CHANGE_ID} --env=dev"
            }
        }
        stage('Deploy (DEV/PR ENV) API and App') {
            agent { label 'deploy' }
            when {
                expression {
                    return env.CHANGE_TARGET != 'dev' && env.CHANGE_TARGET != 'staging' && env.CHANGE_TARGET != 'prod';
                }
            }
            steps {
                echo "Deploying API for ${CHANGE_ID}..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=dev"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-tools -- --pr=${CHANGE_ID} --env=dev"
                echo "Deploying APP for ${CHANGE_ID}..."
                sh "cd app/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=dev"
            }
        }
        stage('Sonarqube') {
            agent {
                label 'deploy'
            }
            when {
                environment name : 'CHANGE_TARGET', value: 'dev'
            }
            steps {
                script {
                    echo "Running Sonarqube"
                    checkout scm
                    dir('.jenkins/sonarqube/sonar-runner') {
                        sh returnStdout: true,
                            script: "./gradlew sonarqube -Dsonar.host.url=https://sonarqube-8ecbmv-tools.pathfinder.gov.bc.ca -Dsonar.projectKey=invasives-app -Dsonar.verbose=true --stacktrace --info"
                        // sleep(30)
                        sh returnStdout: true,
                           script: "./gradlew sonarqube -Dsonar.host.url=https://sonarqube-8ecbmv-tools.pathfinder.gov.bc.ca -Dsonar.projectKey=invasives-api -Dsonar.verbose=true --stacktrace --info"
                        // sleep(30)
                        sh "oc extract secret/sonarqube-status-urls --to=${env.WORKSPACE}/sonar-runner --confirm"
                        SONARQUBE_STATUS_JSON = sh(returnStdout: true, script: "curl -w '%{http_code}' '${SONARQUBE_STATUS_URL}'")
                        SONARQUBE_STATUS = sonarGetStatus (SONARQUBE_STATUS_JSON)
                        if ( "${SONARQUBE_STATUS}" == "ERROR") {
                            echo "Sonarqube scan failed"
                            currentBuild.result = 'FAILURE'
                            exit 1
                        } else {
                            echo "Sonarqube scan passed"
                        }
                    }
                }
            }
        }
        podTemplate(
  label: 'owasp-zap', 
  name: 'owasp-zap', 
  serviceAccount: 'jenkins', 
  cloud: 'openshift', 
  containers: [
    containerTemplate(
      name: 'jnlp',
      image: '172.50.0.2:5000/openshift/jenkins-slave-zap',
      resourceRequestCpu: '500m',
      resourceLimitCpu: '1000m',
      resourceRequestMemory: '3Gi',
      resourceLimitMemory: '4Gi',
      workingDir: '/home/jenkins',
      command: '',
      args: '${computer.jnlpmac} ${computer.name}'
    )
  ]
){
  node('owasp-zap') {
    stage('ZAP Security Scan') {

      // Dynamicaly determine the target URL for the ZAP scan ...
      def TARGET_URL = getUrlForRoute(TARGET_ROUTE, TARGET_PROJECT_NAMESPACE).trim()
      def API_TARGET_URL="${TARGET_URL}${API_PATH}/?format=${API_FORMAT}"

      echo "Target URL: ${TARGET_URL}"
      echo "API Target URL: ${API_TARGET_URL}"

      dir('zap') {

        // The ZAP scripts are installed on the root of the jenkins-slave-zap image.
        // When running ZAP from there the reports will be created in /zap/wrk/ by default.
        // ZAP has problems with creating the reports directly in the Jenkins
        // working directory, so they have to be copied over after the fact.
        def retVal = sh (
          returnStatus: true,
          script: "/zap/zap-baseline.py -x ${ZAP_REPORT_NAME} -t ${TARGET_URL}"
          // Other scanner options ...
          // zap-api-scan errors out
          // script: "/zap/zap-api-scan.py -x ${ZAP_REPORT_NAME} -t ${API_TARGET_URL} -f ${API_FORMAT}"
          // script: "/zap/zap-full-scan.py -x ${ZAP_REPORT_NAME} -t ${TARGET_URL}"
        )
        echo "Return value is: ${retVal}"

        // Copy the ZAP report into the Jenkins working directory so the Jenkins tools can access it.
        sh (
          returnStdout: true,
          script: "mkdir -p ./wrk/ && cp ${ZAP_REPORT_PATH} ./wrk/"
        )
      }

      // Stash the ZAP report for publishing in a different stage (which will run on a different pod).
      echo "Stash the report for the publishing stage ..."
      stash name: "${ZAP_REPORT_STASH}", includes: "zap/wrk/*.xml"
    }
  }
}

// The jenkins-python3nodejs template has been purpose built for supporting SonarQube scanning.
podTemplate(
  label: 'jenkins-python3nodejs',
  name: 'jenkins-python3nodejs',
  serviceAccount: 'jenkins',
  cloud: 'openshift',
  containers: [
    containerTemplate(
      name: 'jnlp',
      image: '172.50.0.2:5000/openshift/jenkins-slave-python3nodejs',
      resourceRequestCpu: '1000m',
      resourceLimitCpu: '2000m',
      resourceRequestMemory: '2Gi',
      resourceLimitMemory: '4Gi',
      workingDir: '/tmp',
      command: '',
      args: '${computer.jnlpmac} ${computer.name}'
    )
  ]
){
  node('jenkins-python3nodejs') {

    stage('Publish ZAP Report to SonarQube') {

      // Do a sparse checkout of the sonar-runner folder since it is the only
      // part of the project we need to publish the ZAP report to SonarQube.
      // We're not scanning our source code here ...
      //
      // For this to work the Jenkins Administrator may have to approve the following methods;
      // - method hudson.plugins.git.GitSCM getBranches
      // - method hudson.plugins.git.GitSCM getUserRemoteConfigs
      // - method hudson.plugins.git.GitSCMBackwardCompatibility getExtensions
      // - staticMethod org.codehaus.groovy.runtime.DefaultGroovyMethods plus java.util.Collection java.lang.Object
      echo "Checking out the sonar-runner folder ..."
      checkout([
          $class: 'GitSCM',
          branches: scm.branches,
          extensions: scm.extensions + [
            [$class: 'SparseCheckoutPaths',  sparseCheckoutPaths:[[path:'sonar-runner/']]]
          ],
          userRemoteConfigs: scm.userRemoteConfigs
      ])

      echo "Preparing the report for the publishing ..."
      unstash name: "${ZAP_REPORT_STASH}"

      SONARQUBE_URL = getUrlForRoute(SONAR_ROUTE_NAME).trim()
      SONARQUBE_PWD = getSonarQubePwd().trim()
      echo "URL: ${SONARQUBE_URL}"
      echo "PWD: ${SONARQUBE_PWD}"

      echo "Publishing the report ..."
      // The `sonar-runner` MUST exist in your project and contain a Gradle environment consisting of:
      // - Gradle wrapper script(s)
      // - A simple `build.gradle` file that includes the SonarQube plug-in.
      //
      // An example can be found here:
      // - https://github.com/BCDevOps/sonarqube
      dir('sonar-runner') {
        // ======================================================================================================
        // Set your SonarQube scanner properties at this level, not at the Gradle Build level.
        // The only thing that should be defined at the Gradle Build level is a minimal set of generic defaults.
        //
        // For more information on available properties visit:
        // - https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Gradle
        // ======================================================================================================
        sh (
          // 'sonar.zaproxy.reportPath' must be set to the absolute path of the xml formatted ZAP report.
          // Exclude the report from being scanned as an xml file.  We only care about the results of the ZAP scan.
          returnStdout: true,
          script: "./gradlew sonarqube --stacktrace --info \
            -Dsonar.verbose=true \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectName=${SONAR_PROJECT_NAME} \
            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
            -Dsonar.projectBaseDir=${SONAR_PROJECT_BASE_DIR} \
            -Dsonar.sources=${SONAR_SOURCES} \
            -Dsonar.zaproxy.reportPath=${WORKSPACE}${ZAP_REPORT_PATH} \
            -Dsonar.exclusions=**/*.xml"
        )
      }
    }
  }
}
        stage('Pre-Deploy (Dev) [Static]') {
            agent {
                label 'deploy'
            }
            when {
                environment name : 'CHANGE_TARGET', value: 'dev'
            }
            steps {
                echo "Deploying Postgress [STATIC] ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run pre-deploy -- --pr=${CHANGE_ID} --env=dev --type=static"
                echo "Deploying backup app [STATIC]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-db-backup -- --pr=${CHANGE_ID} --env=dev --type=static"
                echo "Running DB Backup Job [STATIC]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run backup -- --env=dev --backup=true"
                echo "Running DB Migration [STATIC]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run setup -- --pr=${CHANGE_ID} --env=dev --type=static"
                echo "Running DB Seed Job [STATIC]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run seed -- --pr=${CHANGE_ID} --env=dev --type=static"
            }
        }
        stage('Deploy (Dev) API/APP [Static]') {
            agent {
                label 'deploy'
            }
            when {
                environment name : 'CHANGE_TARGET', value: 'dev'
            }
            steps {
                echo "Deploying API [dev] ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=dev --type=static"
                echo "Deploying dev tools ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-tools -- --env=dev --type=static"
                echo "Deploying APP[dev] ..."
                sh "cd app/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=dev --type=static"
            }
        }
        stage('Pre-Deploy (Test)') {
            agent {
                label 'deploy'
            }
            when {
                environment name : 'CHANGE_TARGET', value: 'staging'
            }
            steps {
                echo "Deploying Postgress [TEST] ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run pre-deploy -- --pr=${CHANGE_ID} --env=test --type=static"
                echo "Deploying backup of app [TEST]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-db-backup -- --pr=${CHANGE_ID} --env=test --type=static"
                echo "Running DB Backup Job [TEST]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run backup -- --env=test --backup=true"
                echo "Running DB Migration [TEST]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run setup -- --pr=${CHANGE_ID} --env=test --type=static"
                echo "Running DB Seed Job [TEST]"
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run seed -- --pr=${CHANGE_ID} --env=test --type=static"
            }
        }
        stage('Deploy (TEST) API/APP') {
            agent { label 'deploy' }
            when {
                environment name : 'CHANGE_TARGET', value: 'staging'
            }
            steps {
                echo "Deploying in [TEST] [API]..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=test --type=static"
                echo "Deploying in [TEST] [APP]..."
                sh "cd app/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=test --type=static"
                echo "Deploying dev tools [TEST] ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-tools -- --env=test --type=static"
            }
        }
        stage('Deploy (PROD) API/APP') {
            agent { label 'deploy' }
            when {
                environment name : 'CHANGE_TARGET', value: 'prod'
            }
            steps {
                script {
                    def IS_APPROVED = input(message: "Deploy to PROD?", ok: "yes", parameters: [string(name: 'IS_APPROVED', defaultValue: 'yes', description: 'Deploy to PROD?')])
                    if (IS_APPROVED != 'yes') {
                        currentBuild.result = "ABORTED"
                        error "User cancelled"
                    }
                    echo "Deploying Postgress [PROD] ..."
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run pre-deploy -- --pr=${CHANGE_ID} --env=prod --type=static"
                    echo "Deploying backup of app [PROD]"
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-db-backup -- --pr=${CHANGE_ID} --env=prod --type=static"
                    echo "Running DB Backup Job [PROD]"
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run backup -- --env=prod --backup=true"
                    echo "Running DB Migration [PROD]"
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run setup -- --pr=${CHANGE_ID} --env=prod --type=static"
                    echo "Deploying in [PROD] [API]..."
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=prod --type=static"
                    echo "Deploying in [PROD] [APP]..."
                    sh "cd app/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=prod --type=static"
                    echo "Deploying dev tools [PROD] ..."
                    sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy-tools -- --env=prod --type=static"
                } 
            }
            /*input {
                message "Should we continue with deployment to TEST?"
                ok "Yes!"
            }
            steps {
                echo "Deploying ..."
                sh "cd api/.pipeline && ./npmw ci && DEBUG=* ./npmw run deploy -- --pr=${CHANGE_ID} --env=prod"
            }*/
        }
    }
}